// parallelTransportFrame Plugin
// Initial code generated by Softimage SDK Wizard
// Executed Tue Aug 21 10:03:00 UTC+1000 2012 by Ahmidou Lyazidi
// 
// 
// Tip: You need to compile the generated code before you can load the plug-in.
// After you compile the plug-in, you can load it by clicking Update All in the Plugin Manager.
#include <xsi_application.h>
#include <xsi_context.h>
#include <xsi_pluginregistrar.h>
#include <xsi_status.h>

#include <xsi_icenodecontext.h>
#include <xsi_icenodedef.h>
#include <xsi_command.h>
#include <xsi_factory.h>
#include <xsi_longarray.h>
#include <xsi_doublearray.h>
#include <xsi_math.h>
#include <xsi_vector2f.h>
#include <xsi_vector3f.h>
#include <xsi_vector4f.h>
#include <xsi_matrix3f.h>
#include <xsi_matrix4f.h>
#include <xsi_rotationf.h>
#include <xsi_quaternionf.h>
#include <xsi_color4f.h>
#include <xsi_shape.h>
#include <xsi_icegeometry.h>
#include <xsi_iceportstate.h>
#include <xsi_indexset.h>
#include <xsi_dataarray.h>
#include <xsi_dataarray2D.h>

// Defines port, group and map identifiers used for registering the ICENode
enum IDs
{
	ID_IN_tangentArray = 0,
	ID_IN_normalArray = 1,
	ID_G_100 = 100,
	ID_G_101 = 101,
	ID_OUT_normals = 200,
	ID_TYPE_CNS = 400,
	ID_STRUCT_CNS,
	ID_CTXT_CNS,
	ID_UNDEF = ULONG_MAX
};

XSI::CStatus RegisterparallelTransportFrame( XSI::PluginRegistrar& in_reg );

using namespace XSI; 


XSIPLUGINCALLBACK CStatus XSILoadPlugin( PluginRegistrar& in_reg )
{
	in_reg.PutAuthor(L"Ahmidou Lyazidi");
	in_reg.PutName(L"parallelTransportFrame Plugin");
	in_reg.PutVersion(1,0);

	RegisterparallelTransportFrame( in_reg );

	//RegistrationInsertionPoint - do not remove this line

	return CStatus::OK;
}

XSIPLUGINCALLBACK CStatus XSIUnloadPlugin( const PluginRegistrar& in_reg )
{
	CString strPluginName;
	strPluginName = in_reg.GetName();
	Application().LogMessage(strPluginName + L" has been unloaded.",siVerboseMsg);
	return CStatus::OK;
}

CStatus RegisterparallelTransportFrame( PluginRegistrar& in_reg )
{
	ICENodeDef nodeDef;
	nodeDef = Application().GetFactory().CreateICENodeDef(L"parallelTransportFrame",L"parallelTransportFrame");

	CStatus st;
	st = nodeDef.PutColor(40,100,146);
	st.AssertSucceeded( ) ;


	// Add input ports and groups.
	st = nodeDef.AddPortGroup(ID_G_100);
	st.AssertSucceeded( ) ;

	st = nodeDef.AddInputPort(ID_IN_tangentArray,ID_G_100,siICENodeDataVector3,siICENodeStructureArray,siICENodeContextAny,L"tangentArray",L"tangentArray",MATH::CVector3f(1.0,1.0,1.0),CValue(),CValue(),ID_UNDEF,ID_UNDEF,ID_CTXT_CNS);
	st.AssertSucceeded( ) ;

	st = nodeDef.AddInputPort(ID_IN_normalArray,ID_G_100,siICENodeDataVector3,siICENodeStructureArray,siICENodeContextAny,L"normalArray",L"normalArray",MATH::CVector3f(1.0,1.0,1.0),CValue(),CValue(),ID_UNDEF,ID_UNDEF,ID_CTXT_CNS);
	st.AssertSucceeded( ) ;

	// Add output ports.
	st = nodeDef.AddOutputPort(ID_OUT_normals,siICENodeDataVector3,siICENodeStructureArray,siICENodeContextAny,L"normals",L"normals",ID_UNDEF,ID_UNDEF,ID_CTXT_CNS);
	st.AssertSucceeded( ) ;

	PluginItem nodeItem = in_reg.RegisterICENode(nodeDef);
	nodeItem.PutCategories(L"Custom ICENode");

	return CStatus::OK;
}

XSIPLUGINCALLBACK CStatus parallelTransportFrame_Evaluate( ICENodeContext& in_ctxt )
{
	// The current output port being evaluated...
	ULONG out_portID = in_ctxt.GetEvaluatedOutputPortID( );
  
	switch( out_portID )
	{		
		case ID_OUT_normals :
		{
			// Get the output port array ...			
			CDataArray2DVector3f outData( in_ctxt );
			
 			// Get the input data buffers for each port
			CDataArray2DVector3f tangentArrayData( in_ctxt, ID_IN_tangentArray );
			CDataArray2DVector3f normalArrayData( in_ctxt, ID_IN_normalArray );

			MATH::CVector3f prevTan(1,0,0) ;
			MATH::CVector3f prevNorm(1,0,0) ;
			MATH::CMatrix3f m1(0,0,0,0,0,0,0,0,0);

 			// We need a CIndexSet to iterate over the data 		
			CIndexSet indexSet( in_ctxt );
			for(CIndexSet::Iterator it = indexSet.Begin(); it.HasNext(); it.Next())
			{
				// Add code to set output port...

				CDataArray2DVector3f::Accessor tangentArraySubArray = tangentArrayData[it];
				CDataArray2DVector3f::Accessor normalArraySubArray = normalArrayData[it];

				// Output arrays must always be initialized first
				CDataArray2DVector3f::Accessor outAccessor = outData.Resize( it, normalArraySubArray.GetCount( ) );
				for (ULONG i=0; i<tangentArraySubArray.GetCount( ); i++)
				{
					if(i == 0)
					{
						//prevTan.MulByMatrix3InPlace(initFrameData[it]);
						prevTan = tangentArraySubArray[i] ;
						prevNorm = normalArraySubArray[i] ;
					}
					else
					{
						prevTan = tangentArraySubArray[i-1] ;
						prevNorm = normalArraySubArray[i-1] ;
					}
					MATH::CVector3f axis ;
					axis.Cross(prevTan,tangentArraySubArray[i]);
					axis.NormalizeInPlace();
					float alpha = -(tangentArraySubArray[i].GetAngle(prevTan));

					/*matrixFromAxisAngle(axis,alpha,m1)*/
					float m[3][3];
					double x=axis.GetX();
					double y=axis.GetY();
					double z=axis.GetZ();

					double c = cos(alpha);
					double s = sin(alpha);
					double t = 1.0 - c;

					m[0][0] = c + x*x*t;
					m[1][1] = c + y*y*t;
					m[2][2] = c + z*z*t;

					double tmp1 = x*y*t;
					double tmp2 = z*s;
					m[1][0] = tmp1 + tmp2;
					m[0][1] = tmp1 - tmp2;
					tmp1 = x*z*t;
					tmp2 = y*s;
					m[2][0] = tmp1 - tmp2;
					m[0][2] = tmp1 + tmp2;
					tmp1 = y*z*t;
					tmp2 = x*s;
					m[2][1] = tmp1 + tmp2;
					m[1][2] = tmp1 - tmp2;

					m1.Set(m);
					prevNorm.MulByMatrix3InPlace(m1);
					normalArraySubArray[i] = prevNorm;
					outAccessor[i] = prevNorm;
				}
			}
		}
		break;
		
		// Other output ports...
	};
	
	return CStatus::OK;
}


void matrixFromAxisAngle(MATH::CVector3f a, float angle, MATH::CMatrix3f& m1)
{
	float m[3][3];
	double x=a.GetX();
	double y=a.GetY();
	double z=a.GetZ();
	double c = cos(angle);
	double s = sin(angle);
	double t = 1.0 - c;

	m[0][0] = c + x*x*t;
	m[1][1] = c + y*y*t;
	m[2][2] = c + z*z*t;

	double tmp1 = x*y*t;
	double tmp2 = z*s;
	m[1][0] = tmp1 + tmp2;
	m[0][1] = tmp1 - tmp2;
	tmp1 = x*z*t;
	tmp2 = y*s;
	m[2][0] = tmp1 - tmp2;
	m[0][2] = tmp1 + tmp2;
	tmp1 = y*z*t;
	tmp2 = x*s;
	m[2][1] = tmp1 + tmp2;
	m[1][2] = tmp1 - tmp2;

	m1.Set(m);
}
